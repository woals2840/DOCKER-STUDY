# PART1 - 가상화 기술
## 애플리케이션 서버

- 파일 서버 : 파일 업로드 / 다운로드 → 이미 있는 서버 다운
- DB 서버 : 데이터 조회 / 입력 → 이미 있는 서버 다
- 웹 서버(WEB) : 웹 페이지 → 소스 코드를 통해 개발된 애플리케이션을 실행
    - 클라이언트가 웹 브라우저를 통해 HTTP 요청을 보내면 정적인 웹 페이지 제공
    - ex) html, JavaScript, CSS
- 웹 애플리케이션서버(WAS) : 애플리케이션 → 소스 코드를 통해 개발된 애플리케이션을 실행
    - 프로그래밍 언어로 개발된 백엔드 애플리케이션을 실행하는 서버

## 가상화 기술

<aside>
💡

실제로 존재하는 컴퓨터가 아니지만 **마치 존재하는 것처럼** 만들어주는 기술 → **하나의 컴퓨터에서 여러 개의 컴퓨터**를 사용할 수 있음

</aside>

**가상화 기술을 사용하지 않았을 때**

![스크린샷 2025-03-05 112615.png](attachment:bc30f025-d855-4867-9740-d842ec189448:스크린샷_2025-03-05_112615.png)

1.  가상화 기술을 사용하지 않는다면 하나의 프로그램에 문제가 생긴다면 다른 프로그램에도 영향을 줄 위험이 있다
2. 하나의 프로그램이 사용량이 갑자기 급증해서 리소스를 모두 소모하게 된다면 나머지 프로그램이 정상적으로 작동하지 않을 수 있다.

**가상화 기술을 사용하였을 때**

![스크린샷 2025-03-05 112815.png](attachment:3d2a5b0d-6ea7-4234-9038-07549adcfc3d:스크린샷_2025-03-05_112815.png)

1. 한 대의 컴퓨터에 여러 대의 논리적인 OS를 만들 수 있음
2. 가상으로 만들어진 컴퓨터에는 사용자가 리소스를 직접 분배할 수 있다
    1. 리소스 분배란 하나의 가상 OS가 사용할 수 있는 리소스의 최대값을 정해놓는 것

### 하이퍼바이저 가상화

<aside>
💡

컴퓨터에 설치되는 프로그램으로 OS의 프로그램으로 실행해서 가상화 환경을 관리할 수 있다. 가상 OS를 만들면 사용자가 지정해 놓은 CPU나 메모리 만큼 격리된 공간을 만들 수 있다.

</aside>

![스크린샷 2025-03-05 113707.png](attachment:ce43c438-f939-4f78-a448-b9a591d6bab7:스크린샷_2025-03-05_113707.png)

- 가상환경을 만들 때마다 프로그램을 설치하는 것처럼 디스크 공간을 차지
- 가상환경을 실행하면 프로그램을 실행시키는 것과 마찬가지로 사용자가 지정한 만큼의 CPU와 메모리를 사용
- **호스트 OS** : 물리적인 서버에 설치되는 OS
    - 하이퍼바이저를 설치하여 가상화 환경을 만들 수 있다
    - 물리적은 하드웨어와 직접 연결되어 있다
- **게스트 OS** : 하이퍼바이저는 호스트 OS의 자원을 격리해서 새로운 OS를 실행한 OS → 가상 머신
    - 호스트 OS의 리소스를 나눈 논리적인 공간이다
    - 논리적으로 격리되어 있는 게스트 OS를 일반적으로 가상 머신이라고 부른다
    - 이 가상 머신에서 웹서버나 WAS, DB 같은 서버 프로그램을 프로세스로 실행해서 운영

### 하이퍼바이저 동작원리

![스크린샷 2025-03-08 112552.png](attachment:c3f08c22-54fc-43c3-b1c6-d1c477b4229b:스크린샷_2025-03-08_112552.png)

- 프로세스는 정상적으로 실행되기 위해서 CPU나 메모리 같은 리소스를 사용
- 프로세스가 하드웨어를 사용하기 위해서는 OS를 통해서만 사용할 수 있다
- OS에는 하드웨어를 사용하기 위해서 커널이라는 중요하 도구가 설치되어 있다
- 커널은 하드웨어에 사용 요청을 대신 전달해주는 시스템 콜이라는 표준을 정해놓았음
- 프로세스들은 커널에 시스템 콜을 보내 하드웨어의 자원을 사용
    - 각 OS는 서로 다른 시스템 콜을 사용함(Linux, MacOS)
- 게스트 OS의 커널은 물리적인 하드웨어가 없기 때문에 리소스를 사용하려면 호스트 OS의 커널로 리소스 사용을 요청해야한다
- 하지만 호스트 OS와 게스트 OS의 종류가 다르다면 게스트 OS에서 전달받은 시스템 콜을 호스트 OS는 처리할 수 없음 → 하이퍼바이저가 해결
- 하이퍼바이저를 사용하면 격리된 공간을 만들면서 호스트 OS와 다른 종류의 게스트 OS도 사용할 수 있다
-

## 컨테이너 가상화

<aside>
💡

컨테이너 가상화는 리눅스 커널이 제공하는 LXC 라느 자체 격리 기술에서 출발했다. 커널의 네임스페이스(나눌 수 있는 단위를 정의)와 Cgroups(리소스 사용량 배분 지정) 기능을 이용한다. 이런 LXC 기술을 사용해서 만들어진 각각의 격리된 공간을 컨테이너라고 부른다.

</aside>

- 컨테이너 가상화가 하이퍼바이저보다 선호되는 이유는 가볍고 빠르다는 특징 때문이다
- 컨테이너 가상화는 하이퍼바이저 없이 커널의 자체 기술을 활용한 가상화이다
- 컨테이너 가상화는 커널의 격리 기능을 활용하기 때문 모든 컨테이너는 HotOs의 커널을 공유한다.
- 컨테이너는 호스트 OS의 커널을 공유하기 때문에 호스트 OS와 다른 종류의 OS를 실행할 수 없다는 것이 단점이다.

![스크린샷 2025-03-06 111038.png](attachment:7a5225d6-b47d-4a81-a509-ce3ba969f326:스크린샷_2025-03-06_111038.png)

## 도커

![스크린샷 2025-03-06 111159.png](attachment:c8c5a1c7-653e-4f61-ab8a-a21dbcecb549:스크린샷_2025-03-06_111159.png)

- 도커와 같은 컨테이너 가상화 도구를 컨테이너 플랫폼이라 부른다
- 컨테이너 플랫폼은 자체적으로 가지고 있는 컨테이너 엔진과 컨테이너 런타임으로 이루어져있다
    - 컨테이너 엔진 : 사용자의 요청을 받아서 컨테이너를 관리
    - 컨테이너 런타임 : 직접 커널과 통신하며 실제로 격리된 공간을 만드는 역할을 수행
- 도커는 **runc**라는 컨테이너 런타임 사용

### 도커 아키텍쳐

![스크린샷 2025-03-06 111433.png](attachment:e4af8e06-76a6-40ef-8a43-08a182a2399c:스크린샷_2025-03-06_111433.png)

- 도커는 클라이언트 서버 모델로 실행됨
    - 사용자의 명령을 전달해주는 클라이어트와 실제로 컨테이너를 관리해주는 도커 데몬이라는 것이 존대
    - **도커 데몬** : 컨테이너를 관리하는 기능을 제공하고 도커 D라고 불림
    - 도커 데몬은 컨테이너를 관리하기 위해서 API 명세서를 제공
    - **docker CLI(Command Line Interface)** : 클라이언트가 명령어를 입력하면 이 명령어를 서버의 API 양식에 맞게 만들어서 대신 전달
- 클라이언트는 CLI, 서버는 도커 데몬으로 구성

# PART2 - 이미지와 컨테이너
## 이미지란

<aside>
💡

파일 시스템의 특정 시점을 저장해 놓은 압축 파일이다. 이미지는 제작 단계에서부터 소프트웨어뿐만 아니라 소프트웨어가 실행하기 위해서 필요한 모든 요소들을 미리 준비해서 압축한다.

</aside>

![스크린샷 2025-03-06 113323.png](attachment:ffffa3bc-f46b-4bd1-91f5-7bf4d9f45348:스크린샷_2025-03-06_113323.png)

- Nginx 이미지는 Nginx 개발사가 OS위에 Nginx와 의존성 요소들을 미리 준비하고 Nginx를 실행할 준비가 되어있는 상태 자체를 이미지로 저장한 뒤에 공유한다.
- 도커 런 명령에 nginx라는 이미지 이름을 입력했을 때 이 이미지를 다운받아서 격리된 공간에 컨테이너가 실행이 되고 컨테이너를 실행할 때 이미지 안에 있던 nginx 프로그램이 함께 실행된다.
- 이 이미지를 컨테이너로 실행시키면 호스트 OS 안에서 완전히 격리된 공간인 컨테이너가 만들어진다. 그리고 이 컨테이너 안에서 소프트웨어가 실행됨

## 이미지와 컨테이너

- 프로그램 : 실행 가능한 소프트웨어로 디스크 공간을 차지한다
- 프로세스 : 실행 상태의 소프트웨어로 실행시 CPU, MEM 등의 리소스를 사용한다

![스크린샷 2025-03-06 114205.png](attachment:ea2e11fa-acf5-46a2-b71d-afaa0e4242c9:스크린샷_2025-03-06_114205.png)

- 이미지 : 프로그램이 실행되기 위한 환경이 모두 포함된 파일 시스템
    - 압축 파일의 형태로 호스트 머신의 특정 경로에 위치한다
    - 디스크 공간 차지
    - 하나의 이미지로 여러 개의 컨테이너를 실행시킬 수 있다
    - 동일한 이미지에서 실행한 컨테이너는 부에서 모두 동일한 프로세스로 실행된
- 컨테이너 : 이미지를 실행한 것
    - 동일한 이미지에서 실행한 컨테이너는 내부에서 모두 동일한 프로세스로 실행된다
    - 컨테이너를 실행시키려면 해당하는 이미지를 가지고 있어야한다
    - 이미지를 컨테이너로 실행하는 순간부터 CPU와 메모리를 사용하게 된

## 이미지의 메타데이터

- 메타데이터 : 데이터에 대한 데이터
    - 이미지가 실제로 압축된 데이터라면 메타데이터는 이 이미지에 대한 정보를 기술하는 데이터이다.
- 하나의 이미지는 실제로 압축된 파일과 이 파일의 정보가 저장되어 있는 메타데이터로 구성되어있다.
- env : 애플리케이션이 사용하는 환경 설정 값을 의미한다 → 소프트웨어가 실행 시 참조할 설정 정보이다.
    - env는 키와 값으로 이루어져 있다
    - =을 기준으로 왼쪽이 키, 오른쪽이 값
    - Nginx 이미지에는 소프트웨어 버전과 프로그램을 실행할 때 필요한 파일 경로 등의 정보가 포함되어있다.
- cmd : 컨테이너 실행 시 프로세스 실행 명령어 지정
    - 이미지를 컨테이너로 실행할 때 CMD에 있는 명령어를 통해서 어떤 프로그램을 실행할지를 메타데이터에서 결정
    - 여기서 지정한 Nginx 이미지의 이미지 압축 파일과 메타데이터를 사용해서 격리된 공간인 컨테이너가 만들어진다.
    - 이미지가 컨테이너로 실행될 때 cmd필드에 있는 명령어가 실행이 되는 것임

## 컨테이너 생명주기

![스크린샷 2025-03-09 191108.png](attachment:5ed7567d-275c-45d9-b1a1-7930a499183b:스크린샷_2025-03-09_191108.png)

- 컨테이너는 이미지에서부터 시작
- Created: 생성단계 → docker create
    - 이미지를 컨테이너로 만든 상태
    - 컨테이너를 실행하기 위한 격리된 공간이 만들어지는 상태이다
    - 모든 리소스가 격리된 공간인 컨테이너로 분리된 상태
    - 내부에서 프로세스를 실제로 실행하지 않기 때문에 호스트 OS의 CPU와 메모리를 사용하지 않는다
- 실행 상태 : docker start 명령을 사용하여 컨테이너의 메타데이터의 cmd값을 사용해서 러닝 상태로 만듦
    - 정상적으로 프로세스가 실행 중이며 CPU와 메모리르 사용한다
    - docker run : docker create + docker start → 컨테이너 만듦과 동시에 시
    - 실행 중인 프로세스에 종료나 재시작 신호를 보내면 10초 뒤에 이 신호가 동작함
- pause : 모든 프로세스가 일시 중지 된 상태 → 현재 상태를 모두 메모리에 저장 → CPU는 사용하지 않음
    - unpause하면 일시 중지한 시점부터 시작
- stopped : 실행 중인 프로세스를 완전히 중단 → 메모리와 CPU 사용이 모두 중단
    - 다시 시작하면 프로세스가 처음부터 다시 시작
    - 실행 중인 컨테이너를 삭제하려면 -f를 사용
        - 나는 docker kill과 docker rm 명령어 두 번을 사용했는데 이 방법이 좋은 방법인듯
        - docker rm -f는 컨테이너를 강제종료하고 바로 삭제함
        - docker kill + docker rm은 컨테이너를 먼저 안전하게 종료하고 삭제하는 것임
        - 그러므로 컨테이너의 상태를 고려하지 않고 강제 삭제하는 게 목적이라면 docker rm -f 가 효율적이다
